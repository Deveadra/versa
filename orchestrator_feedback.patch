*** Begin Patch
*** Update File: base/agents/orchestrator.py
@@
-from base.llm.prompt_composer import compose_prompt
-from base.llm.retriever import Retriever
+from base.llm.prompt_composer import compose_prompt
+from base.llm.retriever import Retriever
+from base.learning.feedback import Feedback
+from base.learning.sentiment import quick_polarity
+from base.personality.tone_adapter import ToneAdapter
@@
-        try:
-            self.usage_logger = UsageLogger(self.db)
-            self.miner = HabitMiner(self.db)
-            self.profile_mgr = ProfileManager()
-            self.enricher = ProfileEnricher(self.profile_mgr, self.miner)
-            self.primer = PersonaPrimer(self.profile_mgr, self.miner, self.db)
-        except Exception:
-            # non-fatal if learning modules are not available
-            logger.exception("Learning components not initialized")
-            self.usage_logger = None
-            self.miner = None
-            self.profile_mgr = None
-            self.enricher = None
-            self.primer = None
+        try:
+            self.usage_logger = UsageLogger(self.db)
+            self.miner = HabitMiner(self.db)
+            self.profile_mgr = ProfileManager()
+            self.enricher = ProfileEnricher(self.profile_mgr, self.miner)
+            self.primer = PersonaPrimer(self.profile_mgr, self.miner, self.db)
+            # optional feedback / tone components
+            try:
+                self.feedback = Feedback(self.db)
+            except Exception:
+                self.feedback = None
+            try:
+                profile = self.profile_mgr.load_profile() if self.profile_mgr else {}
+            except Exception:
+                profile = {}
+            try:
+                self.tone_adapter = ToneAdapter(profile)
+            except Exception:
+                self.tone_adapter = None
+            # mapping usage_id -> policy_id for async feedback attribution
+            self.policy_by_usage_id = {}
+        except Exception:
+            # non-fatal if learning modules are not available
+            logger.exception("Learning components not initialized")
+            self.usage_logger = None
+            self.miner = None
+            self.profile_mgr = None
+            self.enricher = None
+            self.primer = None
+            self.feedback = None
+            self.tone_adapter = None
+            self.policy_by_usage_id = {}
*** End Patch

*** Begin Patch
*** Update File: base/agents/orchestrator.py
@@
-        # compose final prompt
-        prompt = compose_prompt(SYSTEM_PROMPT, user_text, persona_text=persona_text, memories=memories, extra_context=kg_context, top_k_memories=3)
-        reply = self.brain.complete(SYSTEM_PROMPT, prompt)
+        # select tone policy (if available) and record it so we can attribute feedback later
+        try:
+            policy = self.tone_adapter.choose_policy() if getattr(self, "tone_adapter", None) else None
+            policy_id = policy["id"] if policy else None
+            # stash last policy for immediate use (and mapping by usage_id later)
+            self.last_policy_id = policy_id
+        except Exception:
+            policy = None
+            policy_id = None
+            self.last_policy_id = None
+
+        # compose final prompt using the composer (persona + memories + extra_context)
+        prompt = compose_prompt(SYSTEM_PROMPT, user_text, persona_text=persona_text, memories=memories, extra_context=kg_context, top_k_memories=3)
+        # optionally: you may inject policy instructions into SYSTEM_PROMPT or extra_context based on policy here
+        # e.g.: if policy_id == "succinct": prompt = "SYSTEM:\nBe succinct.\n\n" + prompt
+        reply = self.brain.complete(SYSTEM_PROMPT, prompt)
+
+        # if we logged a usage for this outgoing reply, attach mapping usage_id -> policy_id so feedback can credit the bandit
+        try:
+            # some flows log usage_id earlier; if present and valid, keep mapping
+            if hasattr(self, "last_usage_id") and getattr(self, "last_usage_id", None):
+                uid = self.last_usage_id
+                if policy_id:
+                    try:
+                        self.policy_by_usage_id[uid] = policy_id
+                    except Exception:
+                        pass
+        except Exception:
+            pass
*** End Patch

*** Begin Patch
*** Update File: base/agents/orchestrator.py
@@
 class Orchestrator(...):
     def __init__(...):
         ...
 
+    def ask_confirmation_if_unsure(self, suggestion: str, confidence: float, usage_id: int = None):
+        \"\"\"Return a short confirmation prompt dict if confidence is below threshold.
+        Caller should send this to the user via the REPL/UI and then call record_user_feedback with the response.
+        \"\"\"
+        try:
+            if confidence is None:
+                return None
+            threshold = 0.60
+            if confidence < threshold:
+                q = f\"I can {suggestion}. Did I get that right?\"
+                return {\"ask_user\": q, \"usage_id\": usage_id}
+            return None
+        except Exception:
+            try:
+                logger.exception(\"ask_confirmation_if_unsure failed\")
+            except Exception:
+                pass
+            return None
+
+    def record_user_feedback(self, usage_id: int, text: str):
+        \"\"\"Record user feedback for a given usage_id, update feedback_events, and reward the tone adapter.\"\"\"
+        try:
+            s = quick_polarity(text)
+            kind = \"confirm\" if s > 0.2 else \"dislike\" if s < -0.2 else \"note\"
+            if getattr(self, 'feedback', None):
+                try:
+                    self.feedback.record(usage_id, kind, text)
+                except Exception:
+                    try:
+                        logger.exception(\"Failed to record feedback\")
+                    except Exception:
+                        pass
+            # reward tone adapter via stored mapping (policy_by_usage_id)
+            try:
+                pid = None
+                if hasattr(self, 'policy_by_usage_id') and usage_id in self.policy_by_usage_id:
+                    pid = self.policy_by_usage_id.get(usage_id)
+                # fallback to last_policy_id if nothing stored
+                if not pid:
+                    pid = getattr(self, 'last_policy_id', None)
+                if getattr(self, 'tone_adapter', None) and pid is not None:
+                    try:
+                        self.tone_adapter.reward(pid, s)
+                    except Exception:
+                        try:
+                            logger.exception(\"Failed to reward tone adapter\")
+                        except Exception:
+                            pass
+            except Exception:
+                try:
+                    logger.exception(\"Error while rewarding tone_adapter\")
+                except Exception:
+                    pass
+        except Exception:
+            try:
+                logger.exception(\"record_user_feedback failed\")
+            except Exception:
+                pass
*** End Patch
